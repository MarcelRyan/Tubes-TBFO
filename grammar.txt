Terminals:
( ) { } [ ] . ? , + - * / % = < > ! " ' : ; ~ ^ null true false function if else var delete let const return do while for break continue try catch finally throw new
Variables:
START_STATE START ALPHABET NUM OTHER COMMENT FREE FIRST MIDCHAR NAME VART VAR CONSTT CONST LETT LET VLC POST_NUM NUMBER FVAR FALSET FALSE TRUET TRUE BOOLEAN STRING_IN STRING_VAL STRING ARRAY_VAL ARRAY OBJECT_VAL OBJECT DELETET DELETE RETURNT RETURN BREAKT BREAK FUNCTIONT FUNC_PARAMETER FUNC_NAME FUNC_PARAMETER_CALL FUNC_CALL FUNC_BLOCK FUNCTION CALL_FUNC VALUE INCL DECL A_OP B_OP C_OP OR_OP L_OP T_OP OP ARITH ARITH_OPERATOR ARITH_ALL EQUAL_OPERATOR BOOLEAN_OPERATOR BITWISE_NUMBER BITWISE_OPERATOR TENARY_OPERATOR OPERATORS BLOCK ALLRET_CONDITION ALLBREAKRET_CONDITION ALLB_CONDITION BREAK_STATE BC_STATE RETURN_STATE ALL_STATE FUNC_BREAK_STATE FUNC_B_STATE FUNC_RETURN_STATE FUNC_ALL_STATE FUNC_STATE EXPRESSION EXPRESSION_STATE EXPRESSION_BODY ELSET ELSEIF_CONDITION ELSE IFT IF_CONDITION IF DOT DO LOOP_BC_STATE LOOP_STATE WHILET WHILE_CONDITION WHILE_BLOCK WHILE_HEADER WHILE FORT FOR_EXPRESSION FOR_BODY FOR_CONDITION FOR_BLOCK FOR NEWT THROWT THROWN THROW_ALL THROW TRY_STATE TRY_BLOCK TRYT TRY_MUST TRY CATCHT CATCH_EXPRESSION CATCH FINALLYT FINALLY CASET CASE NEW_CASE DEFAULTT DEFAULT NEW_DEFAULT SWITCHT SWITCH_STATE SWITCH_BLOCK SWITCH CONDITIONS
Productions:
START_STATE -> START_STATE START_STATE | START ; | CONDITIONS | COMMENT
START -> OPERATORS | VLC | CALL_FUNC | null | DELETE
ALPHABET -> a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
NUM -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
OTHER -> ! | @ | # | $ | % | ^ | & | * | ( | ) | - | = | _ | + | [ | ] | \ | { | } | . | ? | < | > | ~ | |
COMMENT -> /* */
FREE -> FREE FREE | FIRST | MIDCHAR | OTHER
FIRST -> ALPHABET | $ | _
MIDCHAR -> MIDCHAR MIDCHAR | NUM | FIRST
NAME -> FIRST MIDCHAR | FIRST | - NAME
VART -> var
VAR -> VART NAME
CONSTT -> const
CONST -> CONSTT NAME
LETT -> let
LET -> LETT NAME
VLC -> VAR | CONST | LET
POST_NUM -> POST_NUM POST_NUM | NUM
NUMBER -> - POST_NUM | POST_NUM
FVAR -> VLC | NAME
FALSET -> false
FALSE -> FALSET | null
TRUET -> true
TRUE -> TRUET
BOOLEAN -> TRUE | FALSE | NAME | NUMBER | FUNCTION | ! BOOLEAN
STRING_IN -> \ "
STRING_VAL -> STRING_VAL STRING_VAL | ALPHABET | NUM | OTHER | OBJECT | START | NAME | FREE | STRING_IN STRING_VAL STRING_IN
STRING -> STRING STRING | ' STRING_VAL ' | " STRING_VAL " | ' ' | " "
ARRAY_VAL -> ARRAY_VAL , ARRAY_VAL | VALUE
ARRAY -> [ ARRAY_VAL ]
OBJECT_VAL -> OBJECT_VAL , OBJECT_VAL | NAME : VALUE
OBJECT -> { OBJECT_VAL }
DELETET -> delete
DELETE -> DELETET NAME . NAME | DELETET NAME | DELETET NAME [ NUM ]
RETURNT -> return
RETURN -> RETURNT VALUE ; | RETURNT ; | RETURN ( VALUE ) ;
BREAKT -> break
BREAK -> BREAKT ;
CONTINUET -> continue
CONTINUE -> CONTINUET ;
FUNCTIONT -> function
FUNC_PARAMETER -> FUNC_PARAMETER , FUNC_PARAMETER | NAME
FUNC_NAME -> NAME ( FUNC_PARAMETER ) | NAME ( )
FUNC_PARAMETER_CALL -> FUNC_PARAMETER_CALL , FUNC_PARAMETER_CALL | NAME | VALUE | NAME . NAME
FUNC_CALL -> NAME ( FUNC_PARAMETER_CALL ) | NAME ( )
FUNC_BLOCK -> { FUNC_STATE } | BLOCK
FUNCTION -> FUNCTIONT FUNC_NAME FUNC_BLOCK
CALL_FUNC -> NAME . FUNC_NAME | FUNC_NAME
VALUE -> NUMBER | FVAR | BOOLEAN_OPERATOR | STRING | ARRAY | FUNC_CALL | TENARY_OPERATOR | BITWISE_OPERATOR | null
INCL -> NAME + + | + + NAME
DECL -> NAME - - | - - NAME
A_OP -> + | - | % | / | * | * *
B_OP -> & | ^ | ~ | < < | > > | > > > | OR_OP
C_OP -> = = | = = = | ! = | ! = = | > | < | > = | < = | ?
OR_OP -> |
L_OP -> & & | OR_OP OR_OP | !
T_OP -> ?
OP -> A_OP | C_OP | OR_OP | L_OP | T_OP
ARITH -> ARITH A_OP ARITH | VALUE
ARITH_OPERATOR -> FVAR A_OP ARITH
ARITH_ALL -> ARITH | ARITH_OPERATOR
EQUAL_OPERATOR -> FVAR = ARITH_ALL | VALUE = ARITH_ALL | FVAR | VALUE
BOOLEAN_OPERATOR -> BOOLEAN_OPERATOR C_OP BOOLEAN_OPERATOR | BOOLEAN | VALUE
BITWISE_NUMBER -> FVAR | NUMBER
BITWISE_OPERATOR -> BITWISE_NUMBER B_OP BITWISE_NUMBER
TENARY_OPERATOR -> NAME T_OP VALUE : VALUE | ( BOOLEAN_OPERATOR ) T_OP VALUE : VALUE | VALUE T_OP T_OP VALUE | VALUE T_OP T_OP = VALUE
OPERATORS -> ARITH_OPERATOR | EQUAL_OPERATOR | BOOLEAN_OPERATOR | TENARY OPERATOR | INCL | DECL | BITWISE_OPERATOR
BLOCK -> { START_STATE }
ALLRET_CONDITION -> IF_CONDITION | ELSEIF_CONDITION | ELSET
ALLBREAKRET_CONDITION -> WHILE_CONDITION | FOR_CONDITION
ALLB_CONDITION -> SWITCHT EXPRESSION_BODY
BREAK_STATE -> BREAK_STATE BREAK_STATE | START_STATE | BREAK
BC_STATE -> BC_STATE BC_STATE | START_STATE | BREAK | CONTINUE
RETURN_STATE -> RETURN_STATE RETURN_STATE | START_STATE | RETURN
ALL_STATE -> BC_STATE | RETURN
FUNC_BREAK_STATE -> NEW_CASE | NEW_DEFAULT NEW_CASE | NEW_CASE NEW_DEFAULT
FUNC_B_STATE -> FUNC_B_STATE FUNC_B_STATE | BREAK_STATE | RETURN | ALLRET_CONDITION { FUNC_RETURN_STATE } | ALLBREAKRET_CONDITION { FUNC_ALL_STATE } | ALLB_CONDITION { FUNC_BREAK_STATE }
FUNC_RETURN_STATE -> FUNC_RETURN_STATE FUNC_RETURN_STATE | RETURN_STATE | THROW | ALLRET_CONDITION { FUNC_RETURN_STATE } | ALLBREAKRET_CONDITION { FUNC_ALL_STATE } | ALLB_CONDITION { FUNC_BREAK_STATE }
FUNC_ALL_STATE -> FUNC_ALL_STATE FUNC_ALL_STATE | ALL_STATE | THROW | ALLBREAKRET_CONDITION { FUNC_ALL_STATE } | ALLRET_CONDITION { FUNC_ALL_STATE } | ALLB_CONDITION { FUNC_BREAK_STATE }
FUNC_STATE -> FUNC_STATE FUNC_STATE | ALLRET_CONDITION { FUNC_RETURN_STATE } | ALLBREAKRET_CONDITION { FUNC_ALL_STATE } | ALLB_CONDITION { FUNC_BREAK_STATE } | FUNC_RETURN_STATE | THROW
EXPRESSION_STATE -> BOOLEAN_OPERATOR | INCL | DECL | EQUAL_OPERATOR | NAME
EXPRESSION -> ( EXPRESSION ) | EXPRESSION_STATE
EXPRESSION_BODY -> ( EXPRESSION )
ELSET -> else
ELSEIF_CONDITION -> ELSET IFT EXPRESSION_BODY
ELSE -> ELSEIF_CONDITION BLOCK | ELSET BLOCK
IFT -> if
IF_CONDITION -> IFT EXPRESSION_BODY
IF -> IF_CONDITION BLOCK | ELSEIF_CONDITION BLOCK
DOT -> do
DO -> DOT BLOCK
LOOP_BC_STATE -> LOOP_BC_STATE LOOP_BC_STATE | BC_STATE | ALLRET_CONDITION { LOOP_BC_STATE }
LOOP_STATE -> LOOP_STATE LOOP_STATE | BC_STATE | ALLRET_CONDITION { LOOP_BC_STATE }
WHILET -> while
WHILE_CONDITION -> WHILET EXPRESSION_BODY
WHILE_BLOCK -> { LOOP_STATE } | BLOCK
WHILE_HEADER -> WHILE_CONDITION WHILE_BLOCK
WHILE -> DO WHILE_CONDITION | WHILE_HEADER
FORT -> for
FOR_EXPRESSION -> OPERATORS
FOR_BODY -> ( EXPRESSION ; EXPRESSION ; EXPRESSION )
FOR_CONDITION -> FORT FOR_BODY
FOR_BLOCK -> { LOOP_STATE } | BLOCK
FOR -> FOR_CONDITION FOR_BLOCK | FOR_CONDITION 
NEWT -> new
THROWT -> throw
THROWN -> THROWT VALUE
THROW_ALL -> THROWN | THROWT NEWT FUNC_NAME | IF_CONDITION THROWN | ELSEIF_CONDITION THROWN | WHILE_CONDITION THROWN | FOR_CONDITION THROWN
THROW -> THROW_ALL ;
TRY_STATE -> TRY_STATE TRY_STATE | START_STATE | THROW
TRY_BLOCK -> { TRY_STATE }
TRYT -> try
TRY_MUST -> CATCH | CATCH FINALLY
TRY -> TRYT TRY_BLOCK TRY_MUST
CATCHT -> catch
CATCH_EXPRESSION -> CATCHT ( NAME )
CATCH -> CATCH_EXPRESSION TRY_BLOCK
FINALLYT -> finally
FINALLY -> FINALLYT TRY_BLOCK
CASET -> case
CASE -> CASE CASE | CASET VALUE : BREAK_STATE
NEW_CASE -> NEW_CASE NEW_CASE | CASET VALUE : FUNC_B_STATE
DEFAULTT -> default
DEFAULT -> DEFAULTT : BREAK_STATE
NEW_DEFAULT -> DEFAULTT : FUNC_B_STATE
SWITCHT -> switch
SWITCH_STATE -> CASE | DEFAULT CASE | CASE DEFAULT
SWITCH_BLOCK -> { SWITCH_STATE }
SWITCH -> SWITCHT EXPRESSION_BODY SWITCH_BLOCK
CONDITIONS -> IF | WHILE | FOR | FUNCTION | TRY | SWITCH